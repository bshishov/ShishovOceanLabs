1. Arguments - аргументы рабочего шага, Executor - собственно логика рабочего шага, Description - описательная информация
2. Executor создается в момент запроса от рабочего шага это Executor'a (метод GetExecutor). GetExecutor принимает (object) argumentPackage в качестве аргументов рабочего шага, далее эти аргументы передаются экзекютору. Далее вызывается Executor.ExecuteSimple().
3. В методе Integrate в модуле есть информации о регистрации рабочего шага в WorkflowEditor и ProcessDiagram, в последним он создается посредством WorkstepProcessWrapper.
4. Изменить параметры "интеграции", можно изменить группу и имя. Для воркфлоу есть PetrelSystem.WorkflowEditor.RegisteredWorksteps.Processes.FindOrCreateWorkstepGroup(groupName), для процесса просто указываем имя.
5. 1) Запуск из workflowEditor 2) Непосредственно из окошка процессов 3) Можно кодом вызвать (не уверен что это то что вы хотели услышать)
6. Ну мастер как мастер, автогенерит код. У аргументов можно указать название, входной он и/или выходной, описание. В коде входные и выходные параметры отличаются наличием internal у get/set. Атрибутами в коде указываются название и описание аргумента.
7. Транзакции нужны чтобы их откатывать :) В некотором роде обеспечивается целостность данных. Если попытаться изменить данные не в рамках транзакции то данные не обновляться/добавляться в петрель.
8. IPillarGridIntersectionService - сервис пересечений с 3д сеткой (Pillar Grid). Сложно перечислить все сервисы (не уверен являются ли по архитектуре всяки логгеры сервисами, но почему бы и нет), в апи далеко не лазил, но скорее всего это: PetrelLogger - логгирование, PetrelSystem.WorkflowEditor - редактор воркфлоу (добавления групп, записей и т.п), PetrelSystem.ProcessDiagram - менеджмент диаграммы процессов (добавление редактирование процессов и тп), DataManager - менеджмент транзакций.
9. Вот так: IEnumerable<SegmentCellIntersection> CoreSystem.GetService<IPillarGridIntersectionService>().GetPillarGridPolylineIntersections(grid, polyline) этот метод вернет коллекцию пересечения полилайна и сетки.
10. Разница между абсолютной глубиной (True Vertical Depth) и изме-ренной глубиной (Measured Depth): эти глубины представлены в разных системах измерений. Преобразуем мы следующим образом: enteringMD = wellLog.Borehole.Transform(grid.Domain,                             segment.IntersectionPoint.Z, Domain.MD); Преобразование необходимо, поскольку IntersectionPoint представлен в системе сетки (grid.Domain) а нам нужно получить MD в системе каротажной кривой.
11. foreach(), while (justEnumerator.MoveNext()). По ячейкам: foreach, по замерам картожных данных while (enumSamples.MoveNext()) {}
12. Результат контролируется объектом класса Property, можно задать ему имя изменив свойство Name. Чтобы оно отобразилось нужно не забыть закоммитить транзакцию и оно должно быть создано следующим образом: grid.PropertyCollection.CreateProperty(wellLog.WellLogVersion.Template), т.е. должно быть привязано к сетке. Если созданное проперти закоммитить то оно отобразится. Если требуется отобразить его в качестве результата рабочего шага то нужно иметь в аргументах выходной аргумент типа Property.  
